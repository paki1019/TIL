# TCP/IP

- 인터넷에서 컴퓨터들이 서로 정보를 주고 받는데 쓰이는 프로토콜의 집합.
- TCP/IP는 패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP로 구성됨.
- IP는 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서와 받는 순서가 다를 수 있음.
- TCP는 이를 보완해 데이터의 전달을 보증하고, 순서대로 받게 해줌.

## TCP/IP의 계층

![TCP/IP의 계층](http://cfile23.uf.tistory.com/image/213F623C566BAE253BF7A8)

- OSI 7 Layers와 비교했을때 이론보다 실용성에 중점을 둠.

### Application Layer

- 특정 서비스를 제공하기 위해 애플리케이션 끼리 정보를 주고 받을 수 있음.
- FTP, HTTP, SSH, Telnet, DNS, SMTP 등

### Transport Layer

- 송신된 데이터를 수신측 애플리케이션에게 확실히 전달하게 함.
- 포트번호를 식별해서 애플리케이션을 찾아주는 역할을 함.
- TCP, UDP, RTP, RTCP 등.

### Internet Layer

- 수신 측까지 데이터를 전달하기 위해 사용.
- IP 주소를 바탕으로 올바른 목적지로 데이터를 전달.
- IP, ARP, ICMP, RARP, OSPF 등.

### Network Access Layer

- 네트워크에 직접 연결된 기기 간 전송을 할 수 있도록 함.
- 물리적 주소인 MAC 주소를 사용.
- Ethernet, PPP, Token Ring 등.

## TCP/IP 흐름

### 3-Way-Handshaking

- TCP에서 통신을 하는 장치간 서로 연결이 잘 되어있는지 확인하는 과정.
- 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기전에 한쪽이 다른 쪽이 준비되었다는 것을 알수 있도록 함.

![3-Way-Handshaking](https://t1.daumcdn.net/cfile/tistory/225A964D52F1BB6917)

1. 클라이언트에서 서버에 접속을 요청하는 SYN 패킷을 보냄. 클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태가 됨.
2. 서버는 SYN요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송, 클라이언트가 다시 ACK으로 응답하기를 대기. 이때 서버는 SYN_RECEIVED 상태가 됨.
3. 클라이언트는 서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오감. 이때의 B서버 상태가 ESTABLISHED

### 4-Way-Handshaking

- 3-Way-Handshaking이 TCP의 연결을 초기화 할 때 사용한다면, 4-Way-Handshaking은 세션을 종료하기 위해 수행되는 과정.

![4-Way-Handshaking](https://t1.daumcdn.net/cfile/tistory/2152353F52F1C02835)

1. 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송.
2. 서버는 일단 확인메시지 ACK 플래그를 보내고 자신의 통신이 끝날때까지 기다림. 이 상태가 CLOSE_WAIT상태
3. 서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송.
4. 클라이언트는 확인했다는 ACK 플래그를 보냄.

> 만약 Server에서 FIN을 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN패킷보다 늦게 도착하는 상황이 발생하면?
> Client는 Server로부터 FIN을 수신하더라도 일정시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거침. 이를 TIME_WAIT라고 함.

## 신뢰 할 수 있는 TCP

- 요즘 세상에 인터넷 사용간 엄청나게 큰 데이터를 주고 받게 되는데, 이 데이터를 여러개의 패킷으로 쪼개서 보내곤 함.
- 이러한 패킷들은 엄청 복잡한 인터넷을 통해서 전송됨.
- 이러한 복잡한 환경에서 유실되지 않고, 올바른 순서로 도착하도록 하는 것이 TCP
- TCP는 흐름제어, 오류제어, 혼잡제어를 통해 신뢰성있는 데이터 전송을 보장함.

### network에서 발생할 수 있는 4가지 문제

1. 손실: packet이 손실될 수 있는 문제
2. 순서 바뀜 : packet의 순서가 바뀌는 문제
3. Congestion : 네트워크가 혼잡한 문제
4. Overload : receiver가 overload 되는 문제

## 흐름제어(Flow Control)

- 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법
- 수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 수신측 저장용량이 초과되는 문제 발생. 저장용량 초과로 인한 패킷 손실은 불필요한 재전송/응답을 초래함.
- receiver는 sender에게 현재 자신의 상태를 feedback, packet을 지나치게 많이 받지 않도록 조절
- 흐름제어 방식으로는 Stop and Wait, Sliding Window 방식이 있음.

### Stop and Wait

- 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방식

  ![Stop and Wait](https://t1.daumcdn.net/cfile/tistory/263B7D4E5715ECEB32)

### Sliding Window

![Sliding Window](https://t1.daumcdn.net/cfile/tistory/253F7E485715ED5F27)

- 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절.
- 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인(acked)되는대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송

## 혼잡 제어 (Congestion Control)

- 혼잡 현상
  1. 송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달됨.
  2. 만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 됨.
  3. 이 경우 호스트들은 또 다시 재전송을 하게되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실 발생.
- 흐름제어가 송신측과 수신측 사이의 전송속도를 다루는데 비해, 혼잡제어는 호스트와 라우터를포함한 보다 넓은 관점에서 전송 문제를 다룸.

### AIMD(Additive Increase / Multiplicative Decrease)

- 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법
- 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄임.
- 공평한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴하게 됨.
- 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못함. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식

  ### Slow Start (느린 시작)

  - AIMD 방식은 네트워크의 수용량 주변에서는 효율적으로 작동하지만, 처음에 전송 속도를 올리는데 시간이 오래 걸리는 단점이 존재.
  - Slow Start 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려줌. 즉, 한 주기가 지나면 window size가 2배
  - 대신에 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 됨.
  - 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있음, 그러므로 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수 꼴로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가

  ### Fast Retransmit (빠른 재전송)

  - 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우, 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보냄.
  - 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있음.
  - 중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄임.

  ### Fast Recovery (빠른 회복)

  - 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법이다. 이 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작

> 출처
>
> - http://www.incodom.kr/Internet_Protocol_Suite
> - https://www.youtube.com/watch?v=BEK354TRgZ8
> - https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html
