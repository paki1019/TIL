# 도메인 모델링

- 마이크로서비스의 내부 구조는 폴리글랏하게 접근할 수 있다.
  - 애플리케이션을 구현하는 언어나 데이터를 저장하는 저장소를 서비스마다 다양하게 활용할 수 있음.
  - 내부 아키텍처 구조를 서비스 특성에 맞게 다양하게 수립할 수 있음.(도메인 모델 중심 or 트랜젝션 스크립트)

![도메인 모델 형태의 헥사고날 구조](https://engineering-skcc.github.io/assets/images/msa/MSA5.25.png)
![트랜젝션 스크립트 형태의 헥사고날 구조](https://engineering-skcc.github.io/assets/images/msa/MSA5.26.png)

- 단순한 로직인 경우에는 트랜잭션 스크립트 구조로 만들어도 무방. 그러나 비즈니스가 복잡해질수록 비즈니스 개념들을 잘 구조화할 수 있는 도메인 모델 구조가 효과적. 도메인 모델 구조는 복잡함을 다루어 쉽게 표현할 수 있는 구조를 제공학 때문.
- 서비스의 기능 뿐만 아니라 팀의 역량 수준도 고려해야 함.

## DDD의 전술적 설계(도메인 모델링 구성요소)

- 기존 객체 모델링 방식은 자유도가 높아 문제 영역을 파고들수록 여러 층의 복잡한 계층 구조를 만들게 될 가능성이 높음.
- 이를 정리하기 위해 객체들의 역할에 따른 유형을 정의하고, 이러한 규칙에 따라 모델링하면 단순하고 이해하기가 수월해지는데, 이러한 설계 기법을 DDD의 전술적 설계에서 제공함.

### 엔티티

- 엔티티는 다른 엔티티와 구별할 수 있는 식별자를 가진 도메인의 실체 개념을 표현하는 객체.
- 식별자는 고유하되 엔티티의 속성 및 상태는 계속해서 변할 수 있음.
- 도메인에서 개별성(individuality)이 있는 개념을 엔티티로 식별하며, 고유 식별자와 변화 가능성(mutability)이 엔티티와 값 객체를 구분하는 차이점.

![도메인 모델 예시](https://engineering-skcc.github.io/assets/images/msa/MSA5.27.png)

### 값 객체

- 각 속성이 개별적으로 변화하지 않는 개념적 완전성을 모델링한 것.
- 속성과 속성의 합에 의해 전체 개념이 부여되며, 개별 속성이 별개로 수정되지 않고 전체 객체가 한 번에 생성되거나 삭제되는 객체.
- 엔티티와 같이 식별자의 차이에 따라 구별되지 않고 속성과 속성으로 이뤄진 값의 비교에 의해 동일함이 결정됨.
- 값 객체의 특성
  - 도메인 내의 어떤 대상을 측정하고, 수량화하고, 설명.
  - 관련 특징을 모은 필수 단위로 개념적 전체를 모델링.
  - 측정이나 설명이 변경될 때 완벽히 대체 가능.
  - 다른 값과 등가성을 사용해 비교 가능.
  - 값 객체는 일단 생성되면 변경할 수 없음.

### 표준 타입

- 대상의 타입을 나타내는 서술적 객체.
- 엔티티나 값 객체의 속성을 구분하는 용도로 사용.
- 예전에는 보통 코드 값으로 모델링했으나 이러한 방식은 매핑표가 필요하며, 가독성이 떨어져서 이해하기 어려움.
- 컨텍스트에 맞는 이해 가능한 유비쿼터스 용어로 정의하는 것이 바람직.
- 자바 언어에서는 보통 ENUM으로 정의

### 애그리거트

- 앤티티와 값 객체로 모델링하게 되면 자연스럽게 객체 간의 계층구조가 만들어짐. 이러한 연관된 엔티티와 값 객체들의 묶음이 애그리거트.
- 이러한 애그리거트는 1~2개의 엔티티, 값 객체, 표준 타입 등으로 구성되는데, 이들 간에는 비즈니스 의존관계를 맺고 있으며, 비즈니스 정합성을 맞출 필요가 있음. 따라서 이 애그리거트 단위가 트랜잭션의 기본 단위가 됨.
- 애그리거트 내에 있는 엔티티 중 가장 상위의 엔티티를 애그리거트 루트로 정하고, 이 애그리거트 루트를 통해서만 애그리거트 내의 엔티티나 값 객체를 변경할 수 있음.
- 보통 하나의 컨텍스트에 하나의 애그리거트가 식별되거나 하나의 컨텍스트 안에 여러 개의 애그리거트가 존재할 수 있음. 이 경우 다른 애그리거트를 참조해야 할 필요가 있다면 직접 참조하지 않고 참조할 애그리거트 루트의 식별자를 통해 참조하게 함. 직접 참조하는 경우 애그리거트 단위의 트랜잭션 처리도 힘들어지고 의존관계가 점점 복잡해짐.
- 일반적으로 바운디드 컨텍스트를 마이크로서비스로 식별하게 되는데, 애그리거트 또한 별도의 마이크로서비스 후보가 될 수 있음.
- 같은 컨텍스트 내에 여러 개의 애그리거트가 존재할 때 다른 애그리거트의 클래스를 직접 참조하면 별도의 마이크로 서비스로 분리하기 힘드므로, 애그리거트 간 참조는 애그리거트 루트의 식별자를 활용해 간접 참조하는 것이 바람직.

![식별자를 통한 애그리거트 간 참조](https://engineering-skcc.github.io/assets/images/msa/MSA5.28.png)

- 각 애그리거트는 각각의 단일 트랜잭션으로 일관성을 유지, 다른 애그리거트 사이의 일관성이 필요하다면, 도메인 이벤트를 통한 결과적 일관성을 사용해 일관성을 유지.

![결과적 일과성으로 다른 애그리거트 갱신](https://engineering-skcc.github.io/assets/images/msa/MSA5.29.png)

- 이처럼 DDD에서는 명확한 클래스의 유형과 애그리거트 단위 식별을 통해 도메인 모델을 간결하고 단순하게 유지하는 것을 추구.

### 도메인 서비스

- 도메인의 비즈니스 로직 처리가 특정 엔티티나 값 객체에 속하지 않을 때 단독 객체를 만들어서 처리하게 하는데, 이를 도메인 서비스라고 함.
- 도메인 서비스에서는 상태를 관리하지 않고 행위만 존재.
- 도메인 로직을 처리할 때 엔티티나 값 객체와 함께 특정 작업을 처리하고 상태를 본인이 가지고 있지 않고 엔티티나 값 객체에 전달함.

### 도메인 이벤트

- DDD 및 이벤트 스토밍에서 말하는 도메인 이벤트의 구현 객체.
- 서비스 간 정합성을 일치시키기 위해 단위 애그리거트의 주요 상태 값을 담아 전달되도록 모델링.

![도메인 이벤트 발행 예시](https://engineering-skcc.github.io/assets/images/msa/MSA5.30.png)

- 이벤트 발행은 주문 처리를 수행하는 트랜잭션과 묶어서 실행되어야 함.
- 이벤트는 메시지 메커니즘을 통해 다른 서비스에 전달됨.
