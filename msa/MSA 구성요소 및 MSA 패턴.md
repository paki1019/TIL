# MSA 구성요소 및 MSA 패턴

## 마이크로서비스 외부 아키텍처와 내부 아키텍처

![마이크로서비스 외부 아키텍처와 내부 아키텍처](https://engineering-skcc.github.io/assets/images/MSA2.4.png)

- 인프라 영역과 플랫폼 영역, 애플리케이션 영역에 있는 구성요소 및 그것들의 관계를 MSA 외부 아키텍처(outer architecture)라고 함.
- 외부 아키텍처는 마이크로서비스가 운영되는 환경을 정의, 인프라 환경, 플랫폼 환경, 마이크로서비스가 운영되는 애플리케이션 환경을 포함함.
- 실제로 비즈니스가 실행되는 비즈니스 애플리케이션 및 마이크로서비스 내부 구조를 MSA 내부 아키텍쳐(inner architecture)라고 함.

## 인프라 구성요소

### 베어 메탈, 프라이빗 클라우드 환경

- 퍼블릭 클라우드: AWS, 구글, 마이크로소프트, IBM 등에서 제공하는 Iaas(Infrastructure as a Service), Paas(Platform as a Service)
- 베어 메탈 장비: 어떤 소프트웨어도 담지 않은 하드웨어 서버 제품군
- 위 베어 메탈 장비에 가상화 장치를 추가해서 프라이빗 클라우드 환경을 구축할 수도 있음.

### VM과 컨테이너

![VM과 컨테이너](https://miro.medium.com/max/862/1*wOBkzBpi1Hl9Nr__Jszplg.png)

- VM은 하이퍼바이저(hypervisor)라는 소프트웨어를 이용해 하나의 시스템에서 여러 개의 운영체제를 사용하는 기술
- 컨테이너는 하이퍼바이저 없이 컨테이너 엔진을 사용해 가상의 격리된 공간을 생성.
- 게스트 OS를 사용하는 VM의 경우 운영체제 패치 설치나 관련 라이브러리 설치같은 오버헤드가 계속 발생
- 도커 컨테이너는 레이어 단위의 이미지를 포개는 방식으로 구성, 아래의 이점이 있음.

  - 이식성: 어떠한 호스트 커널이나 플랫폼 버전에 상관없이 도커만 있으면 사용 가능하며 동일하게 동작.
  - 신속성: 크기가 작고 가볍기 때문에 빠르게 배포 가능, 문제 발생 시 수정하지 않고 새로 기동하면 됨.
  - 재사용성: 동일한 환경을 재사용해서 쉽게 설정 가능하기 때문에 개발, 테스트, 스테이징, 프로덕트 환경을 동일한 환경으로 구축하기 쉬움.

- 마이크로서비스에는 컨테이너 환경이 더 적합.

### 컨테이너 오케스트레이션

- 컨테이너를 관리하기 위한 기술
- 컨테이너의 자동 배치 및 복제, 장애 복구, 확장 및 축소, 컨테이너 간 통신, 로드 밸런싱 등 컨테이너 관리를 위한 기능 제공.
- 도커 스웜(Docker Swarm), 아파치 메소스(Apache Mesos), 쿠버네티스(Kubernetes) 등이 존재.
- 쿠버네티스는 다음과 같은 기능 제공
  - 자동화된 자원 배정(Automatic binpacking): 각 컨테이너가 필요로 하는 CPU와 메모리를 쿠버네틱스에 요청하면 컨테이너를 노드에 맞춰 자동으로 배치;
  - 셀프 치유(Self-healing): 컨테이너의 이상 유무를 점검(health check)해서 실패한 경우 자동으로 교체하고 재스케줄링.
  - 수평 확장(Horizontal scaling): 일정 CPU 및 메모리 사용량을 초과하면 자동으로 확장.

## 마이크로서비스 운영과 관리를 위한 플랫폼 패턴

- 플랫폼 환경: 마이크로서비스의 원활한 동작을 지원하는 환경
- 애플리케이션을 빌드하고 인프라에 배포할 수 있는 환경이 중요.
- MSA 시스템을 구성하는 수많은 마이크로서비스를 일일이 수동으로 빌드하고 배포한다면 비효율적이로 혼란스러움. 이러한 과정을 통제하고 자동화하는 것이 중요.

### 개발 지원 환경: 데브옵스 인프라 구성

- 데브옵스(DevOps): 개발과 운영이 분리되지 않은 개발 및 운영을 병행할 수 있는 조직 또는 문화, 여기서는 개발과 운영을 병행 가능하게끔 높은 품질로 소프트웨어를 빠르게 개발하도록 지원하는 빌드, 테스트, 배포를 위한 자동화 환경.
- 과거 수동 배포 절차

  1. 개발자는 개발 환경에서 애플리케이션을 완성하고, 컴파일하고 수동으로 테스트한 후 발생한 오류를 수정한 뒤 스테이징 환경에 배포.
  2. 개발자는 운영 환경에 배포하기 전에 스테이징 환경에서 다시 수동으로 테스트, 그러다 오류가 발생하면 첫 환경인 개발 환경으로 돌아가 오류를 수정한 뒤 스테이징 환경에서 다시 테스트를 수행.
  3. 이러한 과정이 무사히 끝나면 배포 승인을 받고 승인 완료 후 배포 담당자가 애플리케이션을 운영 환경에 배포.

- 이러한 수동 빌드/배포 과정은 너무 많은 시간이 소요되므로, 자동화된 빌드나 배포 작업을 지향.
- 자동 빌드 및 배포 절차
  1. 개발자들이 퇴근할 때 매일 자신이 작성한 소스코드와 그것을 테스트한 테스트 코드를 형상관리 시스템이 보냄(Push)
  2. 빌드 도구에서 매일 밤 형상관리 서버의 코드를 가져와(Pull) 통합한 다음, 자동으로 빌드하고 테스트를 실행해 테스트를 수행.
  3. 테스트 수행 결과를 리포트 문서로 기록하고, 빌드된 소스코드를 스테이징 환경에 자동으로 배포.
  4. 다음날 테스터가 스테이징 환경에서 테스트를 수행. 또는 빌드 및 단위 테스트 결과를 개발자가 확인하고 문제가 있다면 즉시 소스코드를 수정.
- CI/CD
  - CI: 지속적 통합(Continuous Integration), 자동으로 통합 및 테스트하고 그 결과를 기록하는 활동.
  - CD: 지속적 제공/배포(Continuous Delivery/Continuous Deployment), 소스코드 저장소에서 빌드한 소스코드의 실행 파일을 실행 환경까지 자동으로 배포하는 방식.

### 빌드/배포 파이프라인 설계

- 빌드/배포 파이프라인: 빌드/배포되는 과정 동안 수행해야 할 태스크가 정의된 것
- 통합 및 배포까지 이어지는 일련의 프로세스를 하나로 연계해서 자동화하고 시각화된 절차로 구축.

```
리포지토리 -> 빌드 & 유닛 테스트 -> 정적 분석 -> 통합 테스트 -> 배포 -> 마이크로 서비스
```

- Infrastructure as Code: 인프라 구성을 프로그래밍하는 것처럼 코드로 정의.
- Infrastructure as Code를 이용하면 배포 파이프라인 절차를 완벽하게 자동화 할 수 있으며, 대규모 인프라 관리를 수행할 수 있고, 쉽게 공유 재사용이 가능.
- 일부는 자동화, 일부는 수동 처리도 가능.
- 마이크로서비스는 각각 별도의 리포지토리를 가지고 있고 독립적으로 수정 및 빌드하고 배포해야 함. 빌드/배포 파이프라인도 마이크로서비스별로 별도로 설계해야 함.

### 마이크로서비스 생태게와 운영 관리 요소의 탄생

- 2010년 넷플릭스는 모노리스 시스템에서 마이크로서비스 기반의 시스템으로 전환하는 작업을 시작. 이때 선택한 것이 AWS의 EC2
- 전체 서비스를 여러 개의 서비스로 분산 구성할 경우, 한 서비스에서 발생한 장애가 다른 서비스로 전파된다거나 여러 서비스에 분산된 로그를 관리해야 하는 불편함, 서비스 하나가 동작하지 않아 시스템의 일부 기능이 동작하지 않아도 그것을 알아채지 못하고 장애가 방치되는 문제들이 발생함.
- 넷플릭스는 이러한 문제의 해결법으로 다양한 서비스와 도구를 오픈소스로 공개함(넷플릭스 OSS)
  - 여러 마이크로서비스 간의 라우팅과 로드 밸런싱을 위한 줄(Zuul)과 리본
  - 모니터링을 위한 히스트릭트(Hystrict)
  - 서비스 등록을 위한 유레카(Eureka)

### 스프링 클라우드: 스프링 부트 + 넷플릭스 OSS

- 스프링 클라우드: 넷플릭스가 공개한 줄, 유레카, 히스트릭트, 리본 등의 넷플릭스 오픈소스를 스프링 부트 프레임워크 기반으로 쉽게 통합한 것.
  ![스프링 클라우드](https://engineering-skcc.github.io/assets/images/MSA2.13.png)
- 스프링 클라우드 서비스 연계 흐름
  1. 모든 마이크로서비스(스프링 클라우드 서비스 포함)는 인프라에 종속되지 않도록 데이터베이스, 파일 등에 저장된 환경 설정 정보를 형상관리 시스템에 연계된 'Config 서비스'에서 가져와 설정 정보를 주입한 후 클라우드 인프라의 개별 인스턴스로 로딩됨.
  2. 로딩과 동시에 '서비스 레지스트리'에 자신의 서비스명과 클라우드 인프라부터 할당받은 물리 주소를 매핑해서 등록.
  3. 클라이언트가 'API 게이트웨이'를 통해 마이크로서비스에 접근하고, 이때 API 게이트웨이는 적절한 라우팅 및 부하 관리를 위한 로드 밸런싱을 수행.
  4. 또한 API 게이트웨이에서 클라이언트가 마이크로서비스에 접근하기 위한 주소를 알기 위해 '서비스 레지스트리' 검색을 통해 서비스의 위치를 가져옴.
  5. 동시에 API 게이트웨이는 클라이언트가 각 서비스에 접근할 수 있는 권한이 있는지 '권한 서비스'와 연계해 인증/인가 처리를 수행.
  6. 이러한 모든 마이크로서비스 간의 호출 흐름은 '모니터링 서비스'와 '추적 서비스'에 의해 모니터링되고 추적됨.
- 위와 같은 처리 흐름은 MSA 주요 아키텍처 패턴으로 자리 잡게 되면서 스프링 클라우드 이외의 AWS, Azure, GCP 등에서도 제공되기 시작함.

### 다양한 서비스의 등록 및 탐색을 위한 서비스 레지스트리, 서비스 디스커버리 패턴

- 서비스 디스커버리(Service Discovery) 패턴
  - 줄(Zuul): 클라이언트가 여러 개의 마이크로서비스를 호출하기 위한 최적의 경로를 찾아주는 라우팅 기능 제공,
  - 리본(Ribbon): 적절한 부하 분산을 위한 로드 밸런싱 기능 제공.
- 서비스 레지스트리(Service Registry) 패턴
  - 유레카: 백엔드 마이크로서비스의 명칭과 유동적인 IP정보를 매핑해서 보관.

![서비스 디스커버리, 서비스 레지스트리](https://engineering-skcc.github.io/assets/images/MSA2.14.png)

- 각 서비스는 인스턴스가 로딩될 때 자신의 서비스 이름과 할당된 IP 주소를 레지스트리 서비스에 등록, 서비스가 종료될 때 제거
- 클라이언트가 해당 서비스명을 호출할 대 라우터가 레지스트리 서비스를 검색해 해당 서비스의 이름과 매핑된 IP 정보를 확인한 후 호출.
- 서비스 레지스트리에는 업무 처리를 위한 마이크로서비스뿐만 아니라 관리와 운영을 위한 기반 서비스의 주소도 함께 보관함. (Config 서비스, 모니터링 서비스, 추적 서비스)
