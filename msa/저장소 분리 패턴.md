# 저장소 분리 패턴

## 통합 저장소

- 기존 모노리스 시스템의 방식
- 애플리케이션 모듈은 분리하되 저장 처리는 모듈별로 격리하지 않고 다른 모듈에서의 호출을 허용하는 구조.
- 데이터베이스 SQL 처리에 비즈니스 로직이 몰리게 되는 경우가 많음(데이터 중심 애플리케이션)
- 특정 관계형 데이터베이스 벤더에 구속되고, 쿼리가 복잡해져 유지보수가 어려워지고, 성능 문제가 발생했을 때 SQL 구문 튜닝이나 저장소 증설(스케일 업)에 의존하게 됨.
- 마이크로서비스로 분리하더라도 통합 데이터베이스의 부하는 여전하기 때문에 마이크로서비스의 자동 확장(스케일 아웃) 기능이 별 소용이 없을 수 있음.

## 저장소 분리 패턴

- 각 마이크로서비스는 각자의 비즈니스를 처리하기 위한 데이터를 직접 소유함.
- 자신이 소유한 데이터는 다른 서비스에 직접 노출하지 않고 각자가 공개한 API를 통해서만 접근할 수 있음.(정보 은닉)
- 저장소가 격리되어 있기 때문에 각 저장소를 자율적으로 선택할 수 있음.(폴리글랏 저장소)
- 데이터를 통한 변경의 파급 효과(영향도)를 줄여 서비스를 독립적으로 만듬.

![저장소 분리 패턴](https://engineering-skcc.github.io/assets/images/msa/MSA3.8.png)

## 분산 트랜잭션 패턴

- 여러 서비스 간의 비즈니스 및 데이터 일관성을 유지할 필요가 있음.
- 전통적인 방법의 2단계 커밋 기법과 사가(Saga) 패턴이 존재

### 2단계 커밋 기법

- 분산 데이터베이스 환경에서 원자성(atomicity)을 보장하기 위해 분산 트랜잭션에 포함되어 있는 모든 노드가 커밋(commit)되거나 롤백(rollback)하는 메커니즘.
- 이 방법은 각 서비스에 잠금(lock in)이 걸려 발생하는 성능 문제 탓에 비효율적.
- 각 서비스가 다른 인스턴스로 로딩되어 있기 때문에 통제도 어려움.
- 서비스 저장소에 따라 각각 다른 문제가 존재하며, MongoDB, NoSQL 저장소는 2단계 커밋 자체를 지원하지 않음.
- 네트워크 장애로 인해 특정 서비스의 트랜잭션이 처리되지 않을 경우 트랜잭션에 묶인 서비스가 즉시 영향을 받게 됨.
- 결국 2단계 커밋을 통한 분산 트랜잭션 처리는 독립적이지 않고 비자율적임.

### 사가(Saga) 패턴

- 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴.
- 여러 분산된 서비스를 하나의 트랜잭션으로 묶지 않고 각 로컬 트랜잭션과 보상 트랜잭션을 이용해 비즈니스 및 데이터의 정합성을 맞춤.
- 각 로컬 트랜잭션은 자신의 데이터베이스를 업데이트한 다음, 사가 내에 있는 다음 로컬 트랜잭션을 트리거하는 메시지 이벤트를 게시해서 데이터의 일관성을 맞춤.
  ![사가(Saga) 패턴](https://engineering-skcc.github.io/assets/images/msa/MSA3.9.png)
- 보상 트랜잭션은 어떤 서비스에서 트랜잭션 처리에 실패할 경우 그 서비스의 앞선 다른 서비스에서 처리된 트랜잭션을 되돌리게 하는 트랜잭션.
  ![사가 패턴 사례](https://engineering-skcc.github.io/assets/images/msa/MSA3.10.png)
  1. 주문 처리가 시작되면 주문 서비스는 임시주문을 생성하고 주문자 정보가 담긴 '주문 생성됨' 이벤트를 발행하고 트랜잭션을 종료.
  2. 고객 서비스가 '주문 생성됨' 이벤트를 확인한 뒤 다음 처리를 수행.
     a. 이벤트에 존재하는 주문자 정보로 고객의 신용한도를 조회해서 신용한도가 충족되면 '신용 승인됨' 이벤트를 발행.
     b. 신용한도가 충족되지 않는다면 '신용한도 초과됨' 이벤트를 발행.
  3. 주문 서비스는 고객 서비스가 발행한 이벤트를 확인해 다음 처리를 수행
     a. 고객 서비스가 발행한 이벤트가 '신용 승인됨'인 경우 주문 승인 처리.
     b. '신용한도 초과됨' 이벤트인 경우 보상 트랜잭션인 주문 처리 취소를 수행.

## 결과적 일관성

- 모든 애플리케이션에는 비즈니스 처리를 위한 규칙이 존재, 이 규칙이 만족되도록 데이터 일관성의 유지가 중요.
- 이전까지는 데이터 일관성이 실시간으로 반드시 맞아야 한다는 생각이 일반적.
- 모든 비즈니스 처리가 반드시 실시간성을 요구하는 것은 아님. 어떤 비즈니스는 데이터의 일관성이 실시간으로 맞지 않더라도 어느 일정 시점이 되었을 때 일관성을 만족해도 됨. 이러한 개념을 결과적 일관성(eventual consistency)라고 함.
- 결과적 일관성의 개념은 고가용성을 극대화 함.

  a. 순차적 동시 일관성을 추구하는 경우 주문 폭주로 인해 결제 처리 오류, 지연으로 인해 주문 처리 또한 지연.
  ![주문 지연 상황 발생](https://engineering-skcc.github.io/assets/images/msa/MSA3.11.png)
  b. 결과적 일관성 추구를 통한 고가용성.
  ![비동기 통신과 사가 패턴 적용](https://engineering-skcc.github.io/assets/images/msa/MSA3.12.png)

  1. 가주문이 생성되고 '가주문됨' 이벤트를 발행. 주문은 독립적 로컬 트랜잭션이기 때문에 끊임없이 받을 수 있음. 주문이 몰릴 경우 주문 서비스만 확장하여 가용성을 높일 수도 있음.
  2. '가주문됨' 이벤트는 메시지 브로커에 비동기로 전송됨.
  3. 결제 서비스는 발행된 '가주문됨' 이벤트를 확인하고 대금 결제 트랜잭션을 수행하고 '결제 처리됨' 이벤트를 발행.
  4. 이메일 서비스는 '결제 처리됨' 이벤트를 확인하고 주문 결제 완료 이메일을 사용자에게 발송.
  5. 주문 서비스는 '결제 처리됨' 이벤트를 확인하고 가주문으로 처리됐던 주문을 최종 승인. 그리고 '최종 주문 완료됨' 이벤트를 발행.
  6. 이메일 서비스는 주문 서비스가 발행한 '최종 주문 완료됨' 이벤트를 확인해 최종적으로 주문이 완료됐다는 이메일을 사용자에게 발송.
  7. 각 서비스는 각기 작업을 수행하다 오류가 발생하면 '실패 이벤트'를 발행해 다른 서비스가 비즈니스 정합성을 맞출 수 있게 함.
  8. 이때 별도로 메시지 큐에 쌓이는 이벤트들을 모니터링 서비스와 연계해 모니터링하고 추적해서 전체적인 비즈니스 정합성 여부를 관리자가 확인할 수 있음.
