# 인증/인가 패턴

## 중앙 집중식 세션 관리

- 기존 모노리스 방식에서 가상 많이 사용하던 방식.
- 서버 세션에 사용자의 로그인 정보 및 권한 정보를 저장하고, 이를 통해 애플리케이션 인증/인가를 판단하는 것.
- 마이크로서비스에서는 사용량에 따라 수시로 수평 확장될 수 있고 로드 밸런싱 처리가 되기 때문에 세션 데이터가 손상될 수 있음.
- 따라서 마이크로서비스는 각자의 서비스에 세션을 저장하지 않고 공유 저장소에 세션을 저장하고 모든 서비스가 동일한 사용자 데이터를 얻게 함.
- 보통 레디스(Redis)나 멤캐시드(Memcached)를 사용.

## 클라이언트 토큰

- 세션은 중앙 서버에 저장되고 토큰은 사용자의 브라우저에 저장됨.
- 토큰은 사용자의 신원 정보를 가지고 있고 서버로 요청을 보낼 때 전송되기 때문에 서버에서 인가 처리를 할 수 있음.
  ![클라이언트 토큰](https://engineering-skcc.github.io/assets/images/MSA2.19.png)

1. 브라우저가 서버에 사용자명과 패스워드로 인증을 요청.
2. 서버는 인증 후 토큰을 생성하고 브라우저에 토큰 + 사용자 인증/인가 정보를 포함해서 전송.
3. 브라우저는 서버 리소스를 요청할 때 토큰을 함께 보냄. 서버의 서비스는 토큰 정보를 확인한 후 접근을 허가함.

## API 게이트웨이를 사용한 클라이언트 토큰

- 사용자 인증 프로세스는 토큰 인증 프로세스와 유사. 차이점은 API 게이트웨이가 외부 요청의 입구로 추가되는 것.
- 인증/인가를 처리하기 위한 별도의 전담 서비스(인증 서비스)를 만들어서 다른 서비스의 인증/인가 처리를 위임할 수 있음.
- 인증 서비스를 이용하면 각 리소스 서비스가 자체적으로 인증/인가를 처리하지 않고 업무 처리에 집중할 수 있음.

![API 게이트웨이를 사용한 클라이언트 토큰](https://engineering-skcc.github.io/assets/images/MSA2.20.png)

1. 클라이언트가 리소스 서비스에 접근을 요청하면 API 게이트웨이는 인증 서비스에 전달.
2. 인증 서비스는 해당 요청이 인증된 사용자가 보낸 것인지(인증), 해당 리소스에 대한 접근 권한이 있는지(인가) 확인하고, 모두 확인하고 나면 리소스에 접근 가능한 증명서인 액세스 토큰을 발급.
3. 클라이언트는 액세스 토큰을 활용해 다시 접근을 요청.
4. 각 리소스 서비스는 이러한 요청이 액세스 토큰을 포함하고 있는지를 판탄해서 리소스에 대한 접근을 허용.
