# 읽기와 쓰기 분리: CQRS 패턴

- 서비스의 성능 향상을 위한 서비스 인스턴스를 스케일 아웃해서 여러 개로 실행한 경우 데이터 읽기/수정 작업으로 인한 리소스 교착상태가 발생할 수 있음.
  ![CRUD 기능이 모두 있는 마이크로서비스](https://engineering-skcc.github.io/assets/images/msa/MSA3.13.png)
- 이 문제를 해결하기 위한 방법으로 CQRS(Command Query Responsibility Segregation) 패턴이 존재.
- 비즈니스 요청은 시스템의 상태를 변경하는 명령과, 시스템의 상태를 조회하는 부분으로 나눌 수 있음.
- 일반적인 비즈니스 모델에서 상태를 변경하는 명령보다는 조회하는 명령이 더 많이 쓰임.
- 하나의 저장소에 쓰기 모델과 읽기 모델을 분리하는 방식으로 변화시켜 쓰기 서비스와 조회 서비스를 분리할 수도 있고, 더 나아가 물리적으로 쓰기 트랜잭션용 저장소와 조회용 저장소를 따로 준비할 수 있음.
  ![쓰기와 읽기 분리](https://engineering-skcc.github.io/assets/images/msa/MSA3.14.png)
- 이처럼 쓰기 전략과 조회 전략을 각각 분리하면 쓰기 시스템의 부하를 줄이고, 조회 대기 시간을 줄이는 이점을 얻을 수 있음.

## CQRS 패턴 개념도

![CQRS 패턴의 개념도](https://engineering-skcc.github.io/assets/images/msa/MSA3.15.png)

- 좌측의 명령 측면 마이크로서비스는 입력, 수정, 삭제(Create, Update, Delete) 처리를 하고 저장소로 쓰기에 최적화된 관계형 데이터베이스를 사용. 또한 프로그래밍 언어로 업무 규칙을 표현하기 좋은 자바 언어로 구현.
- 오른쪽 조회 측면의 마이크로서비스는 조회 성능이 높은 몽고디비나 엘라스틱서치 같은 NoSQL 데이터베이스를 저장소로 사용. 프로그래밍 언어도 조회를 간단하게 구현할 수 있는 스크립트 기반의 Node.js를 사용. 조회 서비스는 사용량이 많기 떄문에 스케일 아웃해서 인스턴스를 증가시켜둠.
- 위 구조에서 명령 서비스와 조회 서비스간의 데이터 일관성 유지를 위해 이벤트 주도 아키텍처로 데이터를 최신 상태로 동기화함.(결과적 일관성)

## API 조합과 CQRS

- 마이크로서비스의 저장소가 격리되어 있고 각 마이크로서비스마다 각기 다른 기능을 구현했을 때 여러 개의 마이크로서비스를 연계해서 서비스를 제공하는 경우 API 조합(composition) 또는 CQRS를 사용할 수 있음.

### API 조합

![API 조합](https://engineering-skcc.github.io/assets/images/msa/MSA3.16.png)

- 주문 이력 서비스는 제품 서비스가 제공하는 제품 정보, 주문 서비스의 주문 정보, 고객 서비스의 특정 고객 정보, 배송 서비스의 배송 정보가 모두 필요. 따라서 각 기능을 제공하는 마이크로서비스를 조합하는 상위 마이크로서비스를 만들어 조합된 기능을 제공할 수 있음. 하위 서비스는 각자 독립적인 API를 제공해 연계 API를 위해 상위 서비스에 제공.
- 이러한 구조는 상위 서비스가 하위 서비스에 의존하는 결과를 가져옴. 상위 서비스가 제공하는 API에 정보를 제공하는 하위 서비스 중 하나라도 API를 변경하면 상위 서비스는 그에 따라 변경되게 됨.
- 또한 하위 서비스의 실패가 상위 서비스에 영향을 줌. 서비스간 의존성이 큼.

### CQRS 적용

![CQRS 패턴을 이용한 기능 연계](https://engineering-skcc.github.io/assets/images/msa/MSA3.17.png)

- 주문 이력 마이크로서비스가 독자적인 저장소를 가지고, 주문 이력의 세세한 원천 정보를 보유하고 있는 각자의 서비스도 독자적으로 자신의 저장소를 가지고 서비스를 제공.
- 원천 정보를 보유한 여러 마이크로서비스는 자신의 서비스의 정보가 변경되는 시점에 변경 내역을 각자의 변경 이벤트로 발행.
- 주문 이력 마이크로서비스에서는 이 이벤트를 구독하고 있다가 이벤트를 가져와서 자신의 서비스의 저장소에 기록함으로써 다른 서비스의 데이터와 데이터 일관성을 맞추고 서비스의 주문 이력 조회 기능으로 제공.
- 이 경우 다른 원천 서비스가 순간적인 장애가 생긴다고 해도 주문 이력 서비스가 영향을 받지는 않음. 서비스간 직접적인 의존성 적음.

## 쓰기 최적화: 이벤트 소싱 패턴

- 사가 패턴 및 CQRS 패턴에서 비즈니스 불일치를 피하기 위해서는 저장소에 저장하는 것과 메시지를 보내는 것이 원자성을 지녀야 함.
- 객체의 상태 변화를 이벤트 메시지로 발행하고 또 객체 상태를 관계형으로 데이터베이스에 저장하는 경우 SQL 질의어로 변환해서 처리하기가 매우 번거롭고 까다로움. 또 메시지 발행과 저장 처리라는 두 가지 기능을 수행하므로 빠르지도 않음.
- 보통 비즈니스 처리를 수행할 때 데이터 처리는 항상 처리 상태의 결과값을 계산하고 데이터의 최종 상태를 확정해서 저장하는 방식으로 진행됨.
- 쇼핑몰 예시
  1. 사용자 A의 장바구니 객체 생성 -> 장바구니 테이블에 사용자 A의 장바구니 로우(row) 생성.
  2. 품목 1 객체 추가 -> 품목 테이블에 사용자 A 장바구니의 품목 1 추가.
  3. 품목 2 객체 추가 -> 품목 테이블에 사용자 A 장바구니의 품목 2 추가.
  4. 품목 1 객체 제거 -> 품목 테이블에 사용자 A 장바구니의 품목 1 삭제.
  5. 품목 2 객체의 수량 변경 -> 품목 테이블에 사용자 A 장바구니의 품목 2의 수량 정보를 수정.
- 이와 같은 과정은 복잡해지고 변환 처리로 느림. 또한 인스턴스가 여러 개로 확장될 때 동시 업데이트 및 교착상태로부터 안전하지 못할 수도 있음.
- 이에 대한 대안으로 나온 것이 이벤트 소싱(event sourcing) 기법.

### 이벤트 소싱(event sourcing) 기법

- 객체 상태를 데이터 모델에 맞춰 계산하지 않고 상태 트랜잭션 자체를 저장하는 것.
- 이렇게 하면 메시지 브로커와 데이터 저장소를 분리하지 않고 하나로 사용할 수 있음. 복잡한 과정이 없으므로 쓰기 속도도 개선.
- 현재 상태가 필요할 경우, 상태의 출발점부터 모든 기록된 상태 변경 트랜잭션을 순차적으로 계산.
- 처음부터 모든 트랜잭션을 처리하는 것이 부담일 경우 매일 자정의 상태를 스냅숏으로 저장, 현재 상태가 필요하면 스냅숏 이후의 트랜잭션만 처리. 이 같은 방식은 특정 시점의 상태가 필요하면 재현할 수도 있기 떄문에 별도의 트랜잭션성 이력 로그 데이터를 기록할 필요도 없음.
- 명령 측면과 조회 측면의 서비스가 이벤트 저장소에 대한 CRUD를 모두 처리할 필요 없이 '입력/조회(CR)'만 처리하면 됨. 저장소에서 변경과 삭제가 발생하지 않기 때문에 명령 측면의 서비스를 여러 개 확장해도 동시 업데이트 및 교착상태가 발생하지 않음.

![이벤트 스트림 저장](https://engineering-skcc.github.io/assets/images/msa/MSA3.18.png)

- 이벤트 스트림 저장소는 오로지 추가만 가능하게끔 해서 계속 이벤트들이 쌓이게 만들고, 실제로는 내가 필요한 데이터를 구체화하는 시점에서 그때까지 축적된 트랜잭션을 바탕으로 상태를 계산해서 구성.
- 이벤트 저장소는 이벤트 데이터베이스의 역할뿐 아니라 메시지 브로커처럼 작동. 데이터 저장 처리 메커니즘과 메시지 큐 같은 이벤트를 전달하기 위한 메커니즘을 통합해서 복잡성을 줄이고 특히 쓰기 성능을 최적화함.
- 상태를 저장하기 떄문에 정확한 감사 로깅을 제공하고, 객체의 예전 상태를 재구성하는 것이 간단해지며, 외부 애플리케이션에 이벤트를 전달하는 것도 저장한 이벤트를 그대로 전송하면 되기 떄문에 간편.

![이벤트 소싱 개념도](https://engineering-skcc.github.io/assets/images/msa/MSA3.19.png)

- 이벤트 스토밍 및 CQRS 구현을 기원하는 프레임워크로는 Axon Framework와 Eventuate가 존재.
