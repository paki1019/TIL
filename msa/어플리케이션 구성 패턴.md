# 어플리케이션 구성 패턴

## 바람직한 마이크로서비스의 내부 아키텍처: 클린 마이크로서비스

- 마이크로서비스 내부 구조를 정의할 때 반드시 고려해야 할 한가지는 마이크로서비스 팀에 의한 폴리글랏한 내부 구조를 가질 수 있기 떄문에 마이크로서비스 시스템에서 정의해야 할 마이크로서비스 내부 구조가 다양할 수 있다는 것.

![다양한 아키텍처 패턴의 폴리글랏 마이크로서비스](https://engineering-skcc.github.io/assets/images/msa/MSA_3.9.png)

- 이처럼 마이크로서비스 아키텍처에서 각 서비스는 각기 목표와 활용도에 따라 명확하게 분리되어야 하고, 각 서비스 목적에 따라 적절한 개발 언어 및 저장소, 내부 아키텍처를 정의하는 것이 바람직하다.
- 조회나 아주 간단한 기능의 경우 헥사고날 아키텍처나 클린 아키텍처 방식의 구조를 고수할 필요가 없음.
- 비즈니스 규칙이 복잡한 서비스는 헥사고날 아키텍처나 클린 아키텍처의 구조를 기반으로 정의하는 것이 바람직.

### 3가지 아키텍처가 지향하는 원칙.

- 지향하는 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮추게 해야 함.
- 업무 규칙을 정의하는 비즈니스 로직 영역을 다른 기술 기반 영역으로부터 분리하기 위해 노력.
- 세부 기술 중심, 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 구분.
- 고수준 영역은 저수준 영역에 의존하지 않게 해야 하며, 저수준 영역이 고수준 영역에 의존하게 해야 함.
- 저수준 영역은 언제든지 교체, 확장 가능해야 하며, 이 같은 변화가 고수준 영역에 영향을 줘서는 안 됨.
- 자바처럼 인터페이스 및 추상 클래스를 지원하는 언어의 경우 저수준 영역의 구체 클래스가 고수준 영역의 추상 인터페이스에 의존하게 하는 의존성 역전 원칙을 적용함.
- 인터페이스는 고수준의 안정된 영역에 존재해야 하며, 저수준의 어댑터가 이를 구현함.

![마이크로서비스의 내부 구조 예시](https://engineering-skcc.github.io/assets/images/msa/MSA_3.10.png)

- 내부 영역에서는 맨 안쪽에 도메인이 존재하고 도메인을 서비스가 감쌈.
- 도메인에는 핵심 비즈니스 개념과 규칙을 구현, 서비스에서는 도메인을 호출해서 업무를 처리하는 절차를 기술.
- 외부 영역과 연계하기 위해 서비스 인터페이스를 보유. 서비스 인터페이스는 외부에서 내부 영역을 사용할 수 있도록 API를 제공하고 서비스가 이를 구현.
- 내부 영역에 있는 또 다른 인터페이스는 저장소 처리를 위한 리포지토리(Repository) 인터페이스. 리포지토리 인터페이스는 외부 영역에서 정의하지 않고 내부 영역에서 정의하며, 비즈니스를 처리하는 데 필요한 기본적인 저장소 처리 사항을 추상화해 정의함. 이러면 외부 영역의 저장소 어댑터는 이 리포지토리 인터페이스를 각 저장소에 맞는 저장소 처리 세부 기술로 구현하게 됨.
- 외부 영역에는 저장소 처리 어댑터 뿐만 아니라 다양한 인바운드, 아웃바운드를 처리하는 어댑터가 위치. 모든 아웃바운드 어댑터는 의존 관계 역전의 원칙을 적용해 외부 영역에서 내부 영역에 의조하도록 설계.

## 내부 영역 - 업무 규칙

- 업무 규칙을 정의하는 내부 영역에는 서비스 인터페이스, 서비스 구현체, 도메인, 리포지토리 인터페이스, 도메인 이벤트 인터페이스, API 프락시 인터페이스가 존재.
- 서비스 인터페이스는 외부 영역이 내부 영역에 대해 너무 많이 알지 못하게 하는 역할을 함. 서비스 인터페이스는 정보 은닉 효과도 있으며, 서비스 인터페이스가 없다면 추이 종속성이 발생할 수 있음.
- 리포지토리 인터페이스, 도메인 인터페이스, API 프락시 인터페이스는 의존 관계 역전의 원칙을 지원함. 더 안정된 곳인 고수준 영역에 인터페이스가 존재하고 저수준의 외부 어댑터가 이러한 인터페이스를 구현하게 함.
- 서비스와 도메인은 클린 아키텍처의 유스케이스와 엔티티의 역할과 같음. 도메인은 비즈니스 개념을 표현하고 서비스는 도메인을 활용해 시스템 흐름 처리를 수행.

### 트랜잭션 스크립트 패턴

![트랜잭션 스크립트 패턴](https://engineering-skcc.github.io/assets/images/msa/MSA_3.11.png)

- 트랜잭션 스크립트(Transaction Script) 패턴에서는 비즈니스 개념을 표현하는 도메인 객체가 행위를 가지고 있지 않음.
- 모든 비즈니스 행위, 즉 무언가를 수행하는 책임은 서비스에 있음.
- 서비스는 비즈니스 절차에 따라 절차적으로 도메인 객체를 이용해 모든 처리를 추행함.
- 이러한 방식에서는 시간이 지남에 따라 서비스가 비대해지고 도메인 객체는 점점 정보 묶음의 역할만 수행하게 됨.
- 서비스는 유스케이스 처리의 단위이고 대부분의 비즈니스 로직 처리가 서비스에서 이뤄지므로 비슷한 유스케이스의 경우 서비스에 중복되는 코드가 계속 생겨날 수 있음. 이러한 점은 유지보수를 어렵게 만듬.
- 트랜잭션 스크립트 패턴은 절차식 프로그래밍 방식과 같이 때문에 객체지향 지식이 없어도 일반적으로 쉽게 이해할 수 있는 구조이고 기존 데이터베이스 중심 아키텍처에 익숙하다면 더 쉽게 적응할 수 있음.
- 비즈니스가 간단한 경우에는 쉽게 적용할 수 있으나 비즈니스가 복잡해질 경우 서비스 코드 양이 점점 증가하는 등 데이터베이스 중심 아키텍처에서 겪었던 문제점이 발생할 여지가 큼.

### 도메인 모델 패턴

![도메인 모델 패턴](https://engineering-skcc.github.io/assets/images/msa/MSA_3.12.png)

- 도메인 모델(Domain Model) 패턴은 도메인 객체가 데이터뿐만 아니라 비즈니스 행위를 가지고 있으며, 도메인 객체가 소유한 데이터는 도메인 객체가 제공하는 행위에 의해 은닉됨.
- 도메인 객체는 각 비즈니스 개념 및 행위에 대한 책임을 수행하고, 서비스는 비즈니스 유스케이스를 구현하기 위해 서비스의 행위를 도메인 객체에 일부분 위임해서 처리함.
- 서비스의 책임들이 도메인으로 적절히 분산되기 때문에 서비스가 비대해지지 않고 서비스 메서드는 단순해짐. 도메인 모델 패턴의 도메인 모델은 객체지향 설계의 객체 모델이며 거대한 서비스 클래스 대신 각기 적절한 책임을 가진 여러 클래스로 구성되므로 이해하기 쉽고 관리 및 테스트하기 쉬움.
- 여기서 더 진화해 도메인 주도 설계의 애그리거트(Aggregate) 패턴을 적용할 수 있는 구조이기도 함.
- 도메인 모델이기 때문에 객체지향 지식에 대한 경험과 역량이 필요하며, 잘 만들어진 도메인 모델은 복잡한 비즈니스 로직을 처리하는 데 유용하며, 잘 정의된 도메인 모델은 코드의 양을 줄이고 재사용성도 높임.

### 도메인 주도 설계의 애그리거트 패턴

- 도메인 모델링을 하다 보면 객체 간의 관계를 참조로 표현하게 되는데, 참조로 정의할 경우 일대다(one-to-many) 관계의 객체를 쉽게 사용할 수 있다는 장점이 있다. 그렇지만 업무가 복잡해지면 참조로 인한 다단계 계층 구조가 생기고 점점 참조 관계가 복잡해지고 무거워질 수 있다.
- 이를 개선할 방안으로 최상위에 존재하는 앤티티(Root Entity)를 중심으로 개념의 집합을 분리한 것이 애그리거트 패턴.
- 개념적으로 묶인 엔티티의 모음 전체를 애그리거트라고 함.

![애그리거트 패턴](https://engineering-skcc.github.io/assets/images/msa/MSA_3.13.png)

- 애그리거트 패턴에서는 이처럼 애그리거트를 한 단위로 일관되게 처리하기 위해 다음과 같은 규칙을 부여함.
  - 애그리거트 루트만 참조.
  - 애그리거트 내 상세 클래스를 바로 참조하지 않고 루트를 통해 참조해야 함. 수정할 때도 마찬가지
  - 애그리거트 간의 참조는 객체를 직접 참조하는 대신 기본 키를 사용. 기본 키를 사용하면 느슨하게 연관되고 수정이 필요하지 않는 애그리거트를 함께 수정하는 실수를 방지함.
  - 하나의 트랜잭션으로 하나의 애그리거트만 생성 및 수정.

## 외부 영역 - 세부사항

- 외부 영역은 내부 영역의 서비스 인터페이스를 사용하는 인바운드 어댑터와 내부 영역에서 선언한 아웃바운드 인터페이스를 구현하는 다양한 어댑터로 구성됨.
- 어댑터는 플러그인처럼 언제든지 교체되거나 확장될 수 있어야 하며, 내부 영역이 먼저 정의된 후에 외부 영역의 세부사항은 늦게 정의되어도 상관없도록 해야 함. 이 같은 방식은 소프트웨어를 부드럽게(Soft) 만듬.

![어댑터](https://engineering-skcc.github.io/assets/images/msa/MSA_3.10.png)

### API 퍼블리싱 어댑터

- REST API를 발행하는 인바운드 어댑터.
- 내부 영역의 서비스 인터페이스를 호출해서 REST 형식의 API로 제공.
- 명시적인 REST 리소스 명칭을 정의하고, 각 REST 메서드가 의도에 맞게 서비스 인터페이스를 호출함.
- 엔티티를 직접 제공하지 않고 API의 필요에 맞는 DTO를 생성해서 엔티티를 변환 및 매핑해서 전달하는 것이 바람직함.

### API 프락시 어댑터

- API 프락시 어댑터는 다른 서비스의 API를 호출하는 아웃바운드 어댑터.
- 내부 영역에 정의된 프락시 인터페이스를 구현하며, 다른 서비스의 API는 REST-API가 될 수도 있고 소켓이나 SOAP 프로토콜을 사용하는 API일 수도 있다.

### 저장소 처리 어댑터

- 저장소 처리 어댑터를 구현할 때는 데이터 처리 메커니즘을 선택할 필요가 있음.
- OR 매핑 방식과 SQL 매핑 방식을 사용할 수 있으며, 내부 영역에서 어떤 구조를 선택하든 둘 다 사용할 수 있음. 그러나 일반적으로 트랜잭션 스크립트 패턴을 사용할 경우 SQL 매핑 방식을 사용하고, 도메인 모델 패턴을 사용할 경우 OR 매핑 방식을 많이 선택함.
- SQL 매핑 방식의 프레임워크로는 마이바티스가 가장 많이 사용되며, OR 매핑 방식으로는 JPA나 스프링 데이터(Spring Data)가 많이 사용됨.
- SQL 매핑 방식의 경우 SQL 질의문을 수동으로 작성해야 하는 세밀한 SQL 제어가 필요할 경우 유용.
- OR 매핑 방식은 OR 매퍼가 런타임 시 저장소에 따라 자동으로 질의문을 생성함. 따라서 SQL 작성에 따르는 개발자의 작업량을 줄일 수 있음. 설정 내용에 따라 손쉽게 저장소를 변경할 수 있어, SQL 매퍼 방식보다 유연한 매커니즘.
- 질의문을 수동으로 작성할 필요가 줄어들어 OR 매핑 방식에 익숙해지면 균일한 질의문 품질과 생산성 향상을 꾀할 수 있음.

### 도메인 이벤트 발행 어댑터

- 외부 아키텍처의 서비스 간 비동기 메시지 통신에서 전달 대상이 되는 정보가 도메인 이벤트.
- 도메인 이벤트는 어떤 사건에 따른 상태의 변경 사항을 의미.
- '주문됨', '주문 취소됨' 등의 명칭을 갖는 클래스로 구현되며, 컨슈머(consumer)에게 전달되기 위해 도메인 이벤트 발행 어댑터를 통해 발행됨.
- 애그리거트 패턴을 적용할 경유 도메인 이벤트는 애그리거트에서 발생한 사건이 됨.
- 실제 도메인 이벤트가 생성되는 위치는 내부 영역이며, 도메인 이벤트 발행 어댑터는 내부 영역의 이벤트 인터페이스를 구현해서 아웃바운드로 특정 메시지 큐나 스트림 저장소에 발행하는 역할을 수행.

### 도메인 이벤트 핸들러

- 외부에서 발행된 도메인 이벤틀르 구독해서 내부 영역으로 전달하는 일을 수행.
- 이벤트 상태에 따라 적절한 서비스 인터페이스를 호출해서 내부 영역에 이벤트를 전달함.
