# 서비스 디스커버리

## 서비스 위치 찾기

클라우드가 아닌 환경에서 서비스 위치 확인은 대개 DNS와 네트워크 로드 밸런서로 해결함.
![DNS와 로드밸런서를 사용하는 전통적 서비스 위치 확인모델](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FltENs%2FbtqFXgakiRc%2FkXxkRWgYOQk4VPTE7R2ka0%2Fimg.png)

### 정적서버 그룹에서 실행되는 소수 서비스의 경우

- 서비스 소비자에게 요청
- 로드밸런서는 액서스 경로를 기반으로 라우팅 테이블에서 물리적 주소 찾음
- 해당 서비스를 호스팅하는 서버목록에서 하나를 선택해 요청 전달
- 보조 밸런서가 유휴상태로 대기. 주 로드 밸랜서가 정상인지 핑으로 확인
- 정상이 아니면 보조 로드밸런서가 활성화. 두 로드 밸런서의 IP 주소를 인수해 요청을 처리.

### 클라우드 기반의 마이크로서비스 앱에서 잘 작동하지 못하는 이유

- 단일 장애 지점: 하나의 로드밸런서에 의존, 병목지점이 될 가능성
- 수평 확장의 제약성: 하드웨어 제약으로 수평확장 제약
- 정적관리: 신속히 서비스 등록과 취소 불가
- 복잡성: 서비스 매핑규칙을 수동으로 정의 해야함

## 클라우드에서 서비스 디스커버리

- 고가용성(highly available): 서비스 검색 정보를 서비스 디스커버리 클러스터의 여러 노드가 공유하는 '핫(hot) 클러스터링 환경을 지원. 한 노드가 사용할 수 없게 되면 클러스터의 다른 노드가 인계를 받음.
- 피어 투 피어(P2P, Peer-to-Peer): 클러스터의 각 노드는 서비스 인스턴스의 상태를 공유.
- 부하 분산(load balancing): 요청을 동적으로 부하 분산해서 서비스 디스커버리가 관리하는 모든 서비스 인스턴스에 분배.
- 회복성(resilient): 서비스 디스커버리 클라이언트는 서비스 정보를 로컬에 캐싱. 서비스 디스커버리 서비스가 가용하지 않을 때 캐싱된 정보를 기반으로 서비스를 계속 찾을 수 있고 동작하게 함.
- 장애 내성(fault-tolerant): 서비스 디스커버리는 서비스 인스턴스의 비정상을 탐지하고 가용 서비스 목록에서 인스턴스를 제거함.

### 서비스 디스커버리 아키텍처

서비스 디스커버리의 네 가지 개념.

- 서비스 등록(service registration): 서비스를 서비스 디스커버리 에이전트에 어떻게 등록하는가?
- 클라이언트가 서비스 주소 검색(client lookup of service address): 서비스 클라이언트가 어떻게 서비스 정보를 검색하는가?
- 정보 공유(information sharing): 서비스 정보를 노드 간에 어떻게 공유하는가?
- 상태 모니터링(health monitoring): 서비스가 자신의 상태 정보를 서비스 디스커버리 에이전트에 어떻게 전달하는가?

![서비스 인스턴스가 추가/제거될 때 서비스 디스커버리 에이전트를 업데이트하고 사용자 요청을 처리할 수 있는 상태가 됨](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcfPRhr%2FbtqFXhAn8CC%2F0L2CVgMSuvnwEOZgYBb65k%2Fimg.png)

서비스 인스턴스가 시작하면 서비스 디스커버리 인스턴스가 접근할 수 있는 자신의 물리적 위치와 경로, 포트를 등록함. 서비스의 각 인스턴스는 동일한 서비스 ID로 등록하여 동일한 서비스 인스턴스 그룹을 고유하게 식별함.

서비스는 일반적으로 1개의 서비스 디스커버리 인스턴스에만 등록. 서비스 디스커버리 구현체는 P2P(피어 투 피어) 모델을 사용해 서비스 인스턴스의 데이터를 클러스터에 있는 다른 노드에 전파함.

서비스 인스턴스는 자기 상태를 서비스 디스커버리 서비스에 푸시하거나 서비스 디스커버리 서비스가 인스턴스 상태를 추출. 정상 상태를 반환하지 못한 서비스는 가용한 서비스 인스턴스 풀에서 제거됨.

클라이언트는 서비스 디스커버리 엔진에만 의존해 서비스 위치를 확인.이 방법을 사용하면 등록된 마이크로서비스 인스턴스를 호출할 때마다 서비스 디스커버리 엔진이 호출되기 때문에 서비스 클라이언트가 서비스를 찾고 호출하기 위해 서비스 디스커버리 엔진에 전적으로 의존하므로 취약함.

더 견고한 클라이언트 측 부하분산 방법으로 클라이언트 측 부하 분산이 존재.

1. 소비자가 디스커버리 서비스에 접속한 후 데이터를 서비스 소비자 기기에 로컬 캐시.
2. 클라이언트가 서비스를 호출하려고 할 때마다 서비스 소비자는 캐시에서 위치정보를 검색. 클라이언트 측 캐싱은 '라운드로빈' 부하분산 알고리즘처럼 단순한 알고리즘을 사용해 서비스 호출을 여러 인스턴스로 분산.
3. 클라이언트는 주기적으로 서비스 디스커버리 서비스에 접속해 서비스 인스턴스 캐시를 새로고침.서비스를 호출하는 동안 서비스 호출이 실패하면 로컬에 있는 서비스 디스커버리 캐시가 무효화되고 서비스 디스커버리 클라이언트는 에이전트 목록 새로고침을 시도.

![클라이언트 측 부하 분산 방식은 서비스 클라이언트가 호출할 때마다 서비스 디스커버리를 연결할 필요가 없도록 서비스 위치를 캐시](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FVWuqN%2FbtqFUA9h0J3%2FYAsnNURxzPqKMXG9gP9zVK%2Fimg.png)
