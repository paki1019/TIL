# 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 많은 클래스가 하나 이상의 자원에 의존. 특히 정적 유틸리티 클래스, 싱글톤에서 자원을 아래와 같이 static final 변수로 설정하는 경우가 많음.

```java
public class SpellChecker {
    private static final Lexicon dictionary = ...;
}
```

- 위의 경우 사전을 단 하나만 사용한다고 가정한다는 점에서 그리 훌륭해 보이지 않음. 언어별 사전, 테스트용 사전 등을 고려하면 사전 하나로 이 모든 쓰임에는 대응하기 어려움.
- 필드에서 final 한정자를 제거하고 다른 사전으로 교체하는 메서드를 추가할 수 있지만, 이 방식은 어색하고 오류를 내기 쉬우며 멀티스레드 환경에서는 쓸 수 없음.
- 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않음.
- 클래스가 여러 자원 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원을 사용하게 하는 간단한 패턴이 있으니, 바로 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식인 의존 객체 주입 패턴.

```java
public class SpellChecker {
    private final Lexicon dictionary = ...;

    public SpellChecker(Lexicon dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
    }
}
```

- 위에서는 dictionary 단 하나의 자원만 사용했지만, 자원이 몇 개든 의존 관계가 어떻든 상관없이 잘 동작함.
- 또한 불변을 보장하여 같은 자원을 사용하려는 여러 클라이언트가 의존 객체들을 안심하고 공유할 수 있기도 함.
- 의존 객체 주입은 생성자, 정적 팩터리, 빌더 모두에 똑같이 응용할 수 있음.
- 이 패턴의 쓸만한 변형으로, 생성자에 자원 팩터리를 넘겨주는 방식도 있음.

> 팩터리 메서드 패턴(Factory Method pattern)
>
> - 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체
> - 자바 8의 `Supplier<T>` 인터페이스가 팩터리를 표현한 완벽한 예.

- `Supplier<T>`를 입력으로 받는 메서드는 일반적으로 한정적 와일드카드 타입(bounded wildcard type)을 사용해 팩터리의 타입 매개변수를 제한. 자신이 명시한 타입의 하위 타입이라면 무엇이든 생성할 수 있는 팩터리를 넘길 수 있음.

```java
Mosaic create(Supplier<? extends Tile> tileFactory) {}
```

- 의존 객체 주입이 유연성과 테스트 용이성을 개선해주긴 하지만, 의존성이 수 춘 개나 되는 큰 프로젝트에서는 코드를 어지럽게 만들기도 함. 대거(Dagger), 주스(Guice), 스프링(Spring) 같은 의존 객체 주입 프레임워크를 사용하면 이런 어질러짐을 해소할 수 있다.
