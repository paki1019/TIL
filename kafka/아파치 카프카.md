# 카프카(apache kafka)

![카프카](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbGveTV%2FbtqT7VDJKeu%2FIOADakNu0liMPa39O9VEzK%2Fimg.png)

카프카는 메세지큐 방식으로 대용량 데이터를 수집, 사용자들이 실시간 스트림으로 소비할 수 있게 만들어주는 역할을 하는 데이터 파이프라인.

## 카프카 탄생 배경

카프카는 '링크드인'에서 하나의 서비스가 너무 많은 시스템과 연결되어 발생하는 문제를 해결하기 위해 아래와 같은 목표로 만든 시스템

- 프로듀서와 컨슈머의 분리.
- 메시징 시스템과 같이 영구 메시지 데이터를 여러 컨슈머에게 허용.
- 높은 처리량을 위한 메시지 최적화.
- 데이터가 증가함에 따라 스케일아웃이 가능한 시스템.

카프카를 적용한 이후의 데이터 처리 시스템은 아래와 같은 특성을 가지게 됨.

- 사내 서비스에서 발생하는 모든 이벤트/데이터의 흐름을 중앙에서 관리.
- 카프카가 전사 데이터 파이프라인으로 동작하기 떄문에 모든 데이터 스토어와 여기서 발생하는 데이터/이벤트가 카프카를 중심으로 연결.
- 카프카가 제공하는 데이터를 이용해서 다양한 분석이 가능.
- 개발 입장에서도 여러 데이터 시스템에 의존하지 않고, 카프카에만 데이터를 전달하면 되기 때문에 본연의 업무에만 집중할 수 있음.

## Publish/Subscribe (펍/섭) 시스템

- 카프카는 기본적으로 Publish-Subscribe 모델을 구현한 분산 메시징 시스템.
- Publish-Subscribe 모델은 데이터를 만들어내는 프로듀서(Producer, 생산자), 소비하는 컨슈머(Consumer, 소비자) 그리고 이 둘 사이에서 중재자 역할을 하는 브로커(Broker)로 구성된 느슨한 결합(Loosely Coupled)의 시스템.
- 프로듀서는 브로커를 통해 메시지를 발행(Publish), 이 때 메시지를 전달할 대상을 명시하지는 않으면 관련 메시지를 구독(Subscribe)한 컨슈머가 브로커에게 요청하여 가져가는 식.

![Publish/Subscribe](https://t1.daumcdn.net/cfile/tistory/9961CF3C5C0FBA462C)

## 카프카의 구조

![카프카의 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdy1bXE%2FbtqT6HGI4MQ%2F8DoSGkqIJp3rGkKOXasDt0%2Fimg.png)

- 아파치 카프카는 소스 애플리케이션과 타겟 애플리케이션의 사이에 위치하여 메시지 큐의 역할을 함
- 토픽: 메시지큐
- 프로듀서: 메시지큐에 데이터를 넣는 역할
- 컨슈머: 큐에서 데이터를 가져가는 역할

## 카프카의 특징

### 1. 다중 프로듀서, 다중 컨슈머

카프카의 토픽에 여러 프로듀서가 동시에 메시지를 전송할 수 있으며, 카프카 토픽의 메시지를 여러 컨슈머들이 동시에 읽어 갈 수 있음. 또한 하나의 프로듀서가 여러 토픽에 메시지를 전송할 수도 있으며, 하나의 컨슈머가 여러 토픽에서 메시지를 읽어 갈 수도 있음.

이러한 다중 프로듀서, 다중 컨슈머의 지원을 통해 하나의 카프카 시스템을 통해 다양한 애플리케이션이 데이터를 주고 받을 수 있고, 데이터의 생산자/소비자 관계도 유연하게 구성할 수 있게 있음.

### 2. 파일 시스템에 저장

전통적인 메시징 시스템은 프로듀서가 전송한 메시지를 브로커의 메모리 상에 존재하는 큐(Queue)에 유지하고, 이후 컨슈머가 메시지를 읽어가면 큐에서 메시지를 제거함.

카프카는 프로듀서가 생성한 메시지를 브로커가 위치한 서버의 파일 시스템에 저장하여, 컨슈머는 프로듀서가 생성한 메시지를 바로바로 소비하지 않아도 되며 카프카가 메시지를 보존하고 있는 기간내에서는 언제든지 읽어 갈 수 있음.

이런 방식은 프로듀서와 컨슈머의 속도 차이가 있을 때 유용함. 컨슈머 쪽에 장애가 생겼거나 순간적인 네트워크 트래픽 폭주로 처리가 늦어졌을 때 브로커의 동작에 큰 영향을 주지 않으면서 처리 속도를 따라갈 수 있게 함. 또 컨슈머들이 데이터를 모았다가 처리하는 배치(batch) 처리를 가능하게 해주며, 컨슈머 쪽에서 에러가 생겼을 때 이전에 읽었던 데이터를 다시 읽을 수 있게 해줌.

카프카 브로커가 파일 시스템에 저장한 메시지는 관리자에 의해 설정된 일정 보존 기간동안 사용가능하며 이후 브로커가 위치한 서버의 파일 시스템에서 삭제됨.

### 3. 확장성(Scalability)

카프카 클러스터는 운영중에 확장이 용이하도록 설계됨. 데이터 파이프라인을 구축한 초창기 적은 수의 브로커들로 클러스터를 운영하다가 시스템 트래픽이 높아지면 브로커를 추가해서 클러스터를 확장할 수 있음.

카프카 토픽에 메시지를 전송하는 프로듀서 역시 운영중에 얼마든지 증가시킬 수 있으며, 카프카에서 메시지를 읽어가는 컨슈머의 경우 컨슈머 그룹으로 묶어 컨슈머 그룹에 컨슈머를 추가할 수 있음. 컨슈머 그룹에 컨슈머가 추가되면 컨슈머의 파티션 소유권(Ownership)이 재분배되는 리밸런스 과정을 거쳐 컨슈머 그룹에 속한 컨슈머들이 고르게 파티션을 할당받게 함.

### 4. 고성능

일반적인 범용 메시징 시스템이 트랜잭션(Transaction) 기능, 메시지를 소비했는지 여부확인 기능을 제공하면서 메시징 시스템 내부에서 복잡한 처리와 병목현상으로 성능 저하가 발생하는것이 비해 카프카는 이런 기능을 배제하고 뛰어난 처리량(Throughput)을 갖도록 설계됨.

### 5. 컨슈머의 pull 방식

기존의 메시징 시스템의 경우 브로커가 컨슈머에게 데이터를 전달해주는 "Push 방식"을 채택하곤 했지만, 카프카는 컨슈머가 브로커에게서 메시지를 가져오는 "Pull 방식"을 채택함.

Pull 방식을 사용하면 컨슈머의 처리량을 브로커가 고민할 필요가 없음. 컨슈머는 자신이 처리할 수 있는 만큼의 메시지만 브로커에게서 가져가면 되기 때문에 최적의 메시지처리 성능을 가질 수 있음. 컨슈머의 처리 속도가 프로듀서의 생산 속도보다 느리다면 컨슈머를 추가하여 처리량을 늘릴 수 있음.

## 카프카 살펴보기

### 1. 토픽(Topic)과 파티션(Partition) 그리고 세그먼트 파일(Segment File)

카프카에 전달되는 메시지 스트림의 추상화된 개념을 토픽(Topic)이라 함. 프로듀서는 메시지를 특정 토픽에 발행하고, 컨슈머는 특정 토픽에서 발행되는 메시지를 구독할 수 있음.

![토픽과 파티션](https://t1.daumcdn.net/cfile/tistory/991FDC495C0FC7A903)

프로듀서가 메시지를 특정 토픽에 전송하면 카프카 클러스터는 토픽을 좀 더 세분화된 단위인 파티션(Partition)으로 나누어 관리함. 각 파티션은 카프카 클러스터를 구성하는 브로커들이 고루 나눠 가짐.

특정 파티션으로 전달된 메시지에는 오프셋(Offset)이라고하는 숫자가 할당되고, 오프셋을 이용해서 컨슈머가 메시지를 가져감.

카프카 브로커는 파티션에 저장된 메시지를 파일 시스템에 저장하는데 이 때 만들어지는 파일이 '세그먼트 파일(Segment File)'

### 2. 파티션의 복제(Replication)

카프카는 고가용성(High Availability)을 제공하기 위해 파티션 데이터의 복사본(Replication)을 유지할 수 있음. 몇 개의 복사본을 저장할 것인지는 리플리케이션 팩터(Replication Factor)로 설정할 수 있으며 토픽 별로 다르게 설정 할 수도 있음.

만약 토픽의 리플리케이션 팩터를 N으로 설정하면 N개의 파티션 데이터 복사본이 생성되고 카프카 브로커가 겹치지 않게 나눠가짐. N개의 복사본은 리플리카(Replica)라고 하며 N개중 1개의 리플리카가 리더(Leader)로 선정되어 클라이언트 요청을 담당함. 나머지 N - 1 개의 리플리카는 팔로워(Follower)가 되어 리더의 변경사항을 따라감.

### 3. 프로듀서(Producer)와 컨슈머(Consumer), 컨슈머 그룹(Consumer Group)

카프카의 클라이언트는 기본적으로 프로듀서(Producer)와 컨슈머(Consumer)라는 두 가지 분류가 존재

![프로듀서와 컨슈머, 컨슈머 그룹](https://t1.daumcdn.net/cfile/tistory/991062425C17AF3B11)

프로듀서(Producer)는 메시지를 생성하여 카프카에 전달하는 클라이언트를 의미. 프로듀서가 특정 토픽에 메시지를 전송하면 기본적으로 여러 파티션에 번갈아가며 전송되어 파티션을 골고루 사용하게 됨. 전송 순서가 중요한 메시지의 경우 메시지에 키(Key)값을 할당하고 이 키를 기반으로 특정 파티션에 전송되도록 파티셔너를 작성할 수도 있음.

프로듀서에서 유의해야 할 점은 서로 다른 파티션으로 전송된 메시지의 소비 순서는 보장되지 않는다는 것. 만약 메시지의 처리 순서가 중요한 경우라면 메시지 키와 파티셔너를 이용해 두 개의 메시지가 같은 파티션으로 전송되도록 추가적인 작업이 필요함. 즉, 카프카로 전송된 메시지는 같은 파티션일 경우에만 순서가 보장됨.

![프로듀서 순서](https://t1.daumcdn.net/cfile/tistory/996C97425C17AE820C)

컨슈머(Consumer)는 메시지를 카프카로부터 읽어가는 클라이언트. 카프카의 컨슈머는 컨슈머 그룹(Consumer Group)을 형성하고, 카프카의 토픽을 컨슈머 그룹 단위로 구독함. 토픽의 파티션은 컨슈머 그룹 당 오로지 하나의 컨슈머로만 소비됨. 파티션과 컨슈머의 이런 연결을 소유권(Ownership)이라고 부름.

파티션과 컨슈머의 Ownership 관계는 브로커와 컨슈머의 구성이 변경되지 않는 이상 계속 유지됨. 컨슈머 그룹에 컨슈머가 추가 혹은 제거 된 경우 컨슈머 그룹내에서 파티션의 소유권을 재분배하는 리밸런싱(Rebalancing) 과정이 실행되며, 리밸런싱을 통해 컨슈머 그룹 내의 컨슈머들이 파티션을 고르게 할당받아 소비할 수 있게 됨. 카프카 클러스터에 브로커가 추가/제거 되는 경우 전체 컨슈머 그룹들에서 리밸런싱이 발생함.

컨슈머 그룹의 컨슈머 수가 토픽의 파티션 수보다 많은 경우, 파티션 개수만큼의 컨슈머만 동작하며 나머지 잉여 컨슈머들은 놈.

컨슈머 그룹은 각 파티션에 대해 오프셋(Offset) 값을 할당받으며, 파티션에 저장된 메시지에 할당된 오프셋 값으로 컨슈머 그룹이 해당 파티션에서 어디까지 읽었는지 확인함.

컨슈머가 카프카로부터 메시지를 읽어서 처리한 다음 컨슈머 그룹에 할당된 오프셋을 변경하는 작업을 오프셋 커밋(Commit) 이라고 함.

### 4. Kafka와 Filesystem

카프카로 전송된 메시지는 카프카 내부에서 세그먼트 파일 형태로 저장됨. 파일을 파일시스템에 기록하여 메시지의 영속성(Persistence)을 얻으며, 나중에 다시 특정 메시지를 소비하고 싶을 때 파일 시스템에 저장된 메시지를 읽어서 컨슈머에게 전송할 수 있음.

### 5. 효율성(Efficiency)

메시지의 크기가 작은 경우 네트워크 오버헤드가 상대적으로 커질 수 있는 상황을 해소하기위해 메시지 셋(Message Set)단위로 메시지를 모아서 처리하는 배치(Batch) 처리를 가능하도록 기능을 제공. 메시지를 모아서 처리하는 배치를 이용해서 네트워크 오버헤드도 줄일 수 있고, 디스크에 최대한 연속적으로 메시지를 쓸 수 있는 순차처리의 장점을 얻을 수도 있음.

디스크와 네트워크 채널 사이에 데이터 전송시 발생할 수 있는 오버헤드를 줄이기 위해 sendfile 시스템 호출을 이용하는 제로카피(Zero-copy) 기법을 사용하여 성능향상을 도모함.

> ### 출처
>
> - https://soft.plusblog.co.kr/3
> - https://devuna.tistory.com/87?category=973931
