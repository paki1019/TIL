# 애플리케이션 조립하기

애플리케이션이 시작될 때 클래스를 인스턴스화하고 묶기 위해서 의존성 주입 메커니즘을 이용.

## 왜 조립까지 신경 써야 할까?

왜 유스케이스와 어댑터를 그냥 필요할 때 인스턴스화하면 안 되는 걸까? 그것은 코드 의존성이 올바른 방향을 가리키게 하기 위해서다. 모든 의존성은 안쪽으로, 애플리케이션의 도메인 코드 방향으로 향해야 도메인 코드가 바깥 계층의 변경으로부터 안전하다.

유스케이스가 영속성 어댑터를 호출해야 하고 스스로 인스턴스화한다면 코드 의존성이 잘못된 방향으로 만들어진 것이다. 유스케이스는 인터페이스만 알아야 하고, 런타임에 이 인터페이스의 구현을 제공 받아야 한다.

이 프로그래밍 스타일의 유익한 부수효과 중 하나는 코드를 훨씬 더 테스트하기 쉽다는 것이다. 한 클래스가 필요로 하는 모든 객체를 생성자로 전달할 수 있다면 객체 대신 목으로 전달할 수 있고, 이렇게 되면 격리된 단위 테스트를 생성하기 쉬워진다.

객체 인스턴스를 설정할 책임은 누구에게 있을까? 그리고 어떻게 의존성 규칙을 어기지 않으면서 그렇게 할 수 있을까?

아키텍처에 대해 중립적이고 인스턴스 생성을 위해 모든 클래스에 대한 의존성을 가지는 설정 컴포넌트 (configuration component)가 있어야 한다.

설정 컴포넌트는 우리가 제공한 조각들로 애플리케이션을 조립하는 것을 책임진다. 이 컴포넌트는 다음과 같은 역할을 수행해야 한다.

- 웹 어댑터 인스턴스 생성
- HTTP 요청이 실제로 웹 어댑터로 전달되도록 보장
- 유스케이스 인스턴스 생성
- 웹 어댑터에 유스케이스 인스턴스 제공
- 영속성 어댑터 인스턴스 생성
- 유스케이스에 영속성 어댑터 인스턴스 제공
- 영속성 어댑터가 실제로 데이터베이스에 접근할 수 있도록 보장

더불어 설정 컴포넌트는 설정 파일이나 커맨드라인 파라미터 등과 같은 설정 파라미터의 소스에도 접근할 수 있어야 한다. 애플리케이션이 조립되는 동안 설정 컴포넌트는 이러한 파라미터를 애플리케이션 컴포넌트에 제공해서 어떤 데이터베이스에 접근하고 어떤 서버를 메일 전송에 사용할지 등의 행동 양식을 제어한다.

보다시피 책임이 굉장히 많고 단일 책임 원칙을 위반하지만, 애플리케이션의 나머지 부분을 깔끔하게 유지하기 위해 이처럼 구성요소를 연결하는 바깥쪽 컴포넌트가 필요하다. 그리고 이 컴포넌트는, 작동하는 애플리케이션으로 조립하기 위해 애플리케이션을 구성하는 모든 움직이는 부품을 알아야 한다.

## 평범한 코드로 조립하기

설정 컴포넌트를 구현하는 방법은 여러 가지다. 의존성 주입 프레임워크의 도움 없이 애플리케이션을 만들고 있다면 평범한 코드로도 이러한 컴포넌트를 만들 수 있다.

자바에서는 애플리케이션이 main 메서드로부터 시작된다. main 메서드 안에서 웹 컨트롤러부터 영속성 어댑터까지, 필요한 모든 클래스의 인스턴스를 생성한 후 연결한다.

마지막엔 웹 컨트롤러를 HTTP로 노출하는 애플리케이션 부트스트랩핑 로직을 호출한다.

이 평범한 코드 방식은 애플리케이션을 조립하는 가장 기본적인 방법이다. 하지만 몇 가지 단점이 있다.

첫 번째로, 웹 컨트롤러, 유스케이스, 영속성 어댑터를 전부 생성해야 하기 때문에 완전한 엔터프라이즈 애플리케이션을 실행하기 위해서는 코드의 양이 많다.

두 번째로, 각 클래스가 속한 패키지 외부에서 인스턴스를 생성하기 때문에 이 클래스들은 전부 public 이어야 한다. 이렇게 되면 package-private 접근 제한자를 이용하지 못하기 떄문에 유스케이스가 영속성 어댑터에 직접 접근하는 것을 막지 못한다.

## 스프링의 클래스패스 스캐닝으로 조립하기

스프링 프레임워크를 이용해서 애플리케이션을 조립한 결과물을 애플리케이션 컨텍스트(application context)라고 함. 애플리케이션 컨텍스트는 애플리케이션을 구성하는 모든 객체(bean)를 포함함.

스프링은 애플리케이션 컨텍스트를 조립하기 위한 몇 가지 방법을 제공하는데, 각기 장단점이 존재. 클래스패스 스캐닝(classpath scanning) 방법이 가장 인기 있음.

스프링은 클래스패스 스캐닝으로 클래스패스에서 접근 가능한 모든 클래스를 확인해서 @Component 애너테이션이 붙은 클래스를 찾음. 그러고 나서 이 애너테이션이 붙은 각 클래스의 인스턴스를 만들어 애플리케이션 컨텍스트에 추가함. 필요한 객체들이 모두 생성되면 AccountPersistenceAdapter의 생성자를 호출하고 생성된 객체도 마찬가지로 애플리케이션 컨텍스트에 추가함.

클래스패스 스캐닝 방식을 이용하면 아주 편리하게 애플리케이션을 조립할 수 있다. 적절한 곳에 @Component 애너테이션을 붙이고 생성자만 잘 만들어두면 된다.

클래스패스 스캐닝 방식에는 단점이 있다. 첫 번째로, 클래스에 프레임워크에 특화된 애너테이션을 붙여야 한다는 점에서 침투적이다. 강경한 클린 아키텍처파는 이러한 방식이 코드를 특정한 프레임워크와 결합시키기 떄문에 사용하지 말아야 한다고 주장할것이다.

일반적인 애플리케이션 개발에서는 필요하다면 한 클래스에 애너테이션 하나 정도는 용인할 수 있고, 리팩터링도 그리 어렵지 않게 할 수 있다.

하지만 다른 개발자들이 사용할 라이브러리나 프레임워크를 만드는 입장에서는 사용하지 말아야 할 방법이다. 라이브러리 사용자가 스프링 프레임워크의 의존성에 엮이게 되기 때문.

또 다른 단점은 마법 같은 일이 일어날 수 있다는 점이다. 스프링 전문가가 아니라면 원인을 찾는 데 수일이 걸릴 수 있는 숨겨진 부수효과를 야기할 수 있다는 뜻.

마법 같은 일이 발생하는 이유는 클래스패스 스캐닝이 애플리케이션 조립에 사용하기에는 너무 둔한 도구이기 떄문이다. 이 방법에서는 단순히 스프링에게 부모 패키지를 알려준 후 이 패키지 안에서 @Component가 붙은 클래스를 찾으라고 지시한다.

애플리케이션 컨텍스트에 실제로는 올라가지 않았으면 하는 클래스를 놓치고 에러를 일으킬 수도 있다.

## 스프링의 자바 컨피그로 조립하기

클래스패스 스캐닝이 애플리케이션 조립하기의 곤봉이라면 스프링의 자바 컨피그(Java Config)는 수술용 매스. 덜 지저분하고 프레임워크와 함께 제공되므로 모든 것을 직접 코딩할 필요가 없는 방식.

@Configuration 애너테이션을 통해 이 클래스가 스프링의 클래스패스 스캐닝에서 발견해야 할 설정 클래스임을 표시해둔다. 그러므로 사실 여전히 클래스패스 스캐닝을 사용하고 있는 것이기는 하다. 하지만 모든 빈을 가져오는 대신 설정 클래스만 선택하기 때문에 해로운 마법이 일어날 확률이 줄어든다.

빈 자체는 설정 클래스 내의 @Bean 애너테이션이 붙은 팩터리 메서드를 통해 생성된다.

리포지토리 객체들은 @EnabledJpaRepositories 애너테이션으로 인해 스프링이 직접 생성해서 제공함. 스프링부트가 이 애너테이션을 발견하면 자동으로 우리가 정의한 모든 스프링 데이터 리포지토리 인터페이스의 구현체를 제공할 것이다.

@EnableJpaRepositories를 설정 클래스뿐만 아니라 메인 애플리케이션에도 붙일 수 있지만, 그러면 애플리케이션을 시작할 때마다 JPA를 활성화해서 영속성이 실질적으로 필요 없는 테스트에서 애플리케이션을 실행할 때도 JPA 리포지토리를 활성화할 것이다. 그러므로 이러한 '기능 애너테이션'을 별도의 설정 모듈로 옮기는 편이 애플리케이션을 더 유연하게 만들고, 항상 모든 것을 한꺼번에 시작할 필요 없게 해준다.

PersistenceAdapterConfiguration 클래스를 이용해서 영속성 계층에서 필요로 하는 모든 객체를 인스턴스화하는 매우 한정적인 범위의 영속성 모듈을 만들었다. 이 클래스는 스프링의 클래스패스 스캐닝을 통해 자동으로 선택될 것이고, 우리는 여전히 어떤 빈이 애플리케이션 컨텍스트에 등록될지 제어할 수 있게 된다.

비슷한 방법으로 웹 어댑터, 혹은 애플리케이션 계층의 특정 모듈을 위한 설정 클래스를 만들 수도 있다. 그러면 특정 모듈만 포함하고, 그 외의 다른 모듈의 빈은 모킹해서 애플리케이션 컨텍스트를 만들 수 있다. 이렇게 하면 테스트에 큰 유연성이 생긴다. 심지어 리팩터링을 많이 하지 않고도 각 모듈의 코드를 자체 코드베이스, 자체 패키지, 자체 JAR 파일로 밀어넣을 수 있다.

또한 이 방식에서는 클래스패스 스캐닝 방식과 달리 @Component 애너테이션을 코드 여기저기에 붙이도록 강제하지 않는다. 그래서 애플리케이션 계층을 스프링 프레임워크(혹은 그 외의 어떤 프레임워크)에 대한 의존성 없이 깔끔하게 유지할 수 있다.

하지만 이 방법에도 문제점은 있다. 설정 클래스가 생성하는 빈(이 경우에는 영속성 어댑터 클래스들)이 설정 클래스와 같은 패키지에 존재하지 않는다면 이 빈들은 public으로 만들어야 한다. 가시성을 제한하기 위해 패키지를 모듈 경계로 사용하고 각 패키지 안에 전용 설정 클래스를 만들 수는 있다. 하지만 이렇게 하면 하위 패키지를 사용할 수 없다.

## 유지보수 가능 한 소프트웨어를 만드는 데 어떻게 도움이 될까?

스프링과 스프링 부트(그리고 비슷한 프레임워크들)는 개발을 편하게 만들어주는 다양한 기능들을 제공한다. 그중 하나가 바로 애플리케이션 개발자로서 우리가 제공하는 다양한 부품(클래스)들을 이용해서 애플리케이션을 조립하는 것이다.

클래스패스 스캐닝은 아주 편리한 기능이다. 스프링에게 패키지만 알려주면 거기서 찾은 클래스로 애플리케이션을 조립한다. 이를 통해 애플리케이션 전체를 고민하지 않고도 빠르게 개발할 수 있게 된다.

하지만 코드의 규모가 커지면 금방 투명성이 낮아진다. 어떤 빈이 애플리케이션 컨텍스트에 올라오는지 정확히 알 수 없게 된다. 또 테스트에서 애플리케이션 컨텍스트의 일부만 독립적으로 띄우기가 어려워진다.

반면, 애플리케이션 조립을 책임지는 전용 설정 컴포넌트를 만들면 애플리케이션이 이러한 책임('변경할 이유')으로부터 자유로워진다. 이 방식을 이용하면 서로 다른 모듈로부터 독립되어 코드 상에서 손쉽게 옮겨 다닐 수 있는 응집도가 매우 높은 모듈을 만들 수 있다. 하지만 늘 그렇듯이 설정 컴포넌트를 유지보수하는 데 약간의 시간을 추가로 들여야 한다.
