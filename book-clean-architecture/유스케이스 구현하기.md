# 유스케이스 구현하기

애플리케이션, 웹, 영속성 계층이 현재 아키텍처에서 아주 느슨하게 결합돼 있기 떄문에 필요한 대로 도메인 코드를 자유롭게 모델링할 수 있다. DDD를 할 수도 있고, 풍부하거나(rich) 빈약한(anemic) 도메인 모델을 구현할 수도 있고, 우리만의 방식을 만들어 낼수도 있다.

육각형 아키텍처는 도메인 중심의 아키텍처에 적합하기 떄문에 도메인 엔티티를 만드는 것으로 시작한 후 해당 도메인 엔티티를 중심으로 유스케이스를 구현하겠다.

## 도메인 모델 구현하기

한 계좌에서 다른 계좌로 송금하는 유스케이스를 구현. 입금과 출금을 할 수 있는 Account 엔티티를 만들고 출금 계좌에서 돈을 출금해서 입금 계좌로 돈을 입금하는 것.

## 유스케이스 둘러보기

일반적으로 유스케이스는 다음과 같은 단계를 따름.

1. 입력을 받는다.
2. 비즈니스 규칙을 검증한다.
3. 모델 상태를 조작한다.
4. 출력을 반환한다.

유스케이스는 인커밍 어댑터로부터 입력을 받는다. 유스케이스 코드는 도메인 로직에만 신경 써야 하고 입력 유효성 검증으로 오염되는 안 된다고 생각한다.

유스케이스는 비즈니스 규칙(business rule)을 검증할 책임이 있다. 도메인 엔티티와 이 책임을 공유한다.

비즈니스 규칙을 충족하는 유스케이스는 입력을 기반으로 어떤 방법으로든 모델의 상태를 변경한다. 일반적으로 도메인 객체의 상태를 바꾸고 영속성 어댑터를 통해 구현된 포인트로 이 상태를 전달해서 저장될 수 있게 한다. 유스케이스는 또 다른 아웃고잉 어댑터를 호출할 수도 있다.

마지막 단게는 아웃고잉 어댑터에서 온 출력값을, 유스케이스를 호출한 어댑터로 반환할 출력 객체로 변환하는 것.

넓은 서비스 문제를 피하기 위해 모든 유스케이스를 한 서비스 클래스에 모두 넣지 않고 각 유스케이스별로 분리된 각각의 서비스로 만들겠다.

## 입력 유효성 검증

이 작업은 애플리케이션 계층의 책임에 해당하기 때문에 지금 논의하는 게 적절.

호출하는 어댑터가 유스케이스에 입력을 전달하기 전에 입력 유효성을 검증하면 어떨까?, 유스케이스에서 필요로 하는 것을 호출자(caller)가 몯 검증했다고 믿을 수 있을까? 유스케이스는 하나 이상의 어댑터에서 호출될 텐데, 그러면 유효성 검증을 각 어댑터에 전부 구현해야 한다. 그럼 그 과정에서 실수할 수도 있고, 유효성 검증을 해야 한다는 사실을 잊어버리게 될 수도 있다.

애플리케이션 계층에서 입력 유효성을 검증해야 하는 이유는, 그렇게 하지 않을 경우 애플리케이션 코어의 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있기 때문이다.

입력 모델(input model)이 이 문제를 다루도록 해보자.

자바 Bean Validation API를 사용 필요한 유효성 규칙들을 필드의 애너테이션으로 표현.

입력 모델에 있는 유효성 검증 코드를 통해 유스케이스 구현체 주위에 사실상 오류 방지 게층(anti corruption layer)을 만들었다. 여기서 말하는 계층은 하위 계층을 호출하는 계층형 아키텍처에서의 계층이 아니라 잘못된 입력을 호출자에게 돌려주는 유스케이스 보호막을 의미.

## 생성자의 힘

앞에서 살펴본 입력 모델인 SendMoneyCommand는 생성자에 많은 책임을 지우도 있다. 클래스가 불변이기 떄문에 생성자의 인자 리스트에는 클래스의 각 속성에 해당하는 파라미터들이 포함돼 있다.
생성자가 파라미터의 유효성 검증까지 하고 있기 때문에 유효하지 않은 상태의 객체를 만드는 것은 불가능하다.

파라미터가 많다면 어떻게 해야 할까? 빌더(Builder) 패턴을 활용하면 더 편하게 사용할 수 있지만, 빌더패턴에 필드를 새로 추가해야 하는 상황이 있을 시 , 빌더를 호출하는 코드에 새로운 필드를 추가하는 것을 잊곤 한다.

컴파일러는 이처럼 유효하지 않은 상태의 불변 객체를 만드려는 시도에 대해서는 경고를 해주지 못한다.

빌더 뒤에 숨기는 대신 생성자를 직접 사용했다면 새로운 필드를 추가하거나 필드를 삭제할 때마다 컴파일 에러를 따라 나머지 코드에 변경사항을 반영할 수 있을 것이다.

## 유스케이스마다 다른 입력 모델

각기 다른 유스케이스에 동일한 입력 모델을 사용하기 싶은 생각이 들 때가 있다. ' 계좌 등록하기'와 '계좌 정보 업데이트하기'라는 두 가지 유스케이스 모두 거의 똑같은 계좌 상세 정보가 필요하다.

차이점은 '계좌 정보 업데이트하기' 유스케이스는 업데이트할 계좌를 특정하기 위해 계좌 ID 정보를 필요로 하고, '계좌 등록하기' 유스케이스는 계좌를 귀속시킬 소유자의 ID 정보를 필요로 한다는 것이다. 그래서 두 유스케이스에서 같은 입력 모델을 공유할 경우 '계좌 정보 업데이트하기'에서는 계좌 ID에, '계좌 등록하기'에서는 소유자 ID에 null값을 허용해야 한다.

불변 커맨드 객체 필드에 대해서 null을 유효한 상태로 받아들이는 것은 그 자체로 코드 냄사(code smell)다. 하지만 더 문제가 되는 부분은 이제 입력 유효성을 어떻게 검증하느냐다. 등록 유스케이스와 업데이트 유스케이스는 서로 다른 유효성 검증 로직이 필요하다. 아마도 유스케이스에 커스텀 유효성 검증 로직을 넣어야 할 테고, 이는 신성한 비즈니스 코드를 입력 유효성 검증과 관련된 관심사로 오염시킨다.

각 유스케이스 전용 입력 모델은 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수효과가 발생하지 않게 한다.

## 비즈니스 규칙 검증하기

입력 유효성 검증은 유스케이스 로직의 일부가 아닌 반면, 비즈니스 규칙 검증은 분명히 유스케이스 로직의 일부다. 비즈니스 규칙은 애플리케이션의 핵심이기에 적절하게 잘 다뤄야 한다.

둘 사이의 아주 실용적인 구분점은 비즈니스 규칙을 검증하는 것ㅇ느 도메인 모델의 현재 상태에 적용해야 하는 반면, 입력 유효성 검증은 그럴 필요가 없다는 것이다. 입력 유효성을 검증하는 일은 @NotNull 애너테이션을 붙인 것처럼 선언적으로 구현할 수 있지만 비즈니스 규칙을 검증하는 일은 조금 더 맥락이 필요하다.

입력 유효성을 검증하는 것은 구문상의(syntactical) 유효성을 검증하는 것이라고도 할 수 있다. 반면 비즈니스 규칙은 유스케이스의 맥락 속에서 의미적인(semantical) 유효성을 검증하는 일이라고 할 수 있다.

비즈니스 규칙 검증은 어떻게 구현할까?

가장 좋은 방법은 비즈니스 규칙을 도메인 엔티티 안에 넣는 것이다.

만약 도메인 엔티티에서 비즈니스 규칙을 검증하기가 여의치 않다면 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 해도 된다.

유효성을 검증하는 코드를 호출하고, 유효성 검증이 실패할 경우 유효성 검증 전용 예외를 던진다. 사용자와 통신하는 어댑터는 이 예외를 에러 메시지로 사용자에게 보여주거나 적절한 다른 방법으로 처리한다.

## 풍부한 도메인 모델 vs. 빈약한 도메인 모델

자주 논의되는 사항은 DDD 철학을 따르는 풍부한 도메인 모델(rich domain model)을 구현할 것인지, '빈약한' 도메인 모델(anemic domain model)을 구현할 것인가다.

풍부한 도메인 모델에서는 애플리케이션 코어에 있는 엔티티에서 가능한 한 많은 도메인 로직이 구현된다. 엔티티들은 상태를 변경하는 메서드를 제공하고, 비즈니스 규칙에 맞는 유효한 변경만을 허용한다.

유스케이스는 도메인 모델의 진입점으로 동작한다. 이어서 유스케이스는 사용자의 의도만을 표현하면서 이 의도를 실제 작업을 수행하는 체계화된 도메인 엔티티 메서드 호출로 변환한다. 많은 비즈니스 규칙이 유스케이스 구현체 대신 엔티티에 위치하게 된다.

'빈약한' 도메인 모델에서는 엔티티 자체가 굉장히 얇다. 일반적으로 엔티티는 상태를 표현하는 필드와 이 값을 읽고 바꾸기 위한 getter, setter 메서드만 포함하고 어떤 도메인 로직도 가지지 않는다.

이말인 즉슨, 도메인 로직이 유스케이스 클래스에 구현돼 있다는 것이다. 비즈니스 규칙을 검증하고, 엔티티의 상태를 바꾸고, 데이터베이스 저장을 담당하는 아웃고잉 포트에 엔티티를 전달할 책임 역시 유스케이스 클래스에 있다. '풍부함'이 엔티티 대신 유스케이스에 존재하는 것이다.
